-- Primary key/unique constraint required on the user table so we can refrence it in the book_ratings table
alter table users add primary key (id);

-- Table that houses ratings/comments on a book that users make
create table book_ratings (
    id int generated by default as identity,
    book_id varchar(10) not null references books(id) on delete cascade,
    user_id int not null references users(id),
    rating int not null,
    comment text
);
-- Create index on book_id and user_id columns because Postgres doesn't automatically add them to FK references.
create index book_ratings_to_books_fk on book_ratings(book_id);
create index book_ratings_to_users_fk on book_ratings(user_id);

-- Create a table that will be automatically updated when a rating is added/changed/removed.
create table book_average_ratings (
    book_id varchar(10) primary key references books(id) on delete cascade,
    average_rating numeric(4, 2) not null
);

-- Function that is invoked by the trigger created below
create or replace function update_book_average_ratings() returns trigger as $$
    declare
        _book_id varchar(10);
        _average_rating int;
    begin
        -- Get the associated book_id depending on whether we're inserting, updating, or deleting
        if tg_op = 'INSERT' then
            _book_id = new.book_id;
        else
            _book_id = old.book_id;
        end if;

        -- Sanity check
        if _book_id is null then
            raise exception 'book_id is null, something went wrong... operation %, old: %, new: %', tg_op, old, new;
        end if;
        raise notice 'Recalculating average rating for book %', _book_id;

        -- Calculate the average and upsert the averages table
        select avg(rating) into _average_rating from book_ratings where book_id = _book_id;
        if _average_rating is null then
            raise notice 'No ratings found for %. Setting to zero.', _book_id;
            _average_rating = 0.0;
        end if;

        -- If we got here we have a rating to upsert
        raise notice 'Updating average rating for % to %', _book_id, _average_rating;
        insert into book_average_ratings(book_id, average_rating) values(_book_id, _average_rating)
            on conflict (book_id) do update set average_rating = _average_rating;
        return null; -- result is ignored since this is an AFTER trigger
    end
    $$ language plpgsql;

-- Trigger AFTER records are inserted, updated, or deleted
create trigger trigger_update_book_average_ratings
    after insert or update or delete
    on book_ratings
    for each row execute function update_book_average_ratings();
